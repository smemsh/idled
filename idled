#!/usr/bin/env python3
"""
"""
__url__     = 'http://smemsh.net/src/idled/'
__author__  = 'Scott Mcdermott <scott@smemsh.net>'
__license__ = 'GPL-2.0'

from sys import argv, stderr, exit
from glob import glob
from enum import Enum, IntEnum
from queue import SimpleQueue
from struct import calcsize, iter_unpack
from signal import SIGTERM
from asyncio import to_thread, create_task, wait, run, FIRST_EXCEPTION
from argparse import ArgumentParser, RawTextHelpFormatter
from subprocess import check_output

from os.path import basename
from os import (
    getenv, chdir, read, killpg, getpgid,
    open as osopen, O_RDONLY,
    EX_OK as EXIT_SUCCESS,
    EX_SOFTWARE as EXIT_FAILURE,
)

## /usr/include/linux/input.h:
# struct input_event
# {
#     # sys/time.h bits/types/struct_timeval.h bits/types.h bits/typesizes.h
#     struct timeval time; # long int, long int
#     __u16 type;
#     __u16 code;
#     __s32 value;
# }
#
## linux x86_64 (LP64): long 8, long 8, ushort 2, ushort 2, int 4 == 24 bytes
# $ cc -xc - << %; ./a.out
# #include <linux/input.h>
# #include <stdio.h>
# void main (void) { printf("size: %zu\n", sizeof(struct input_event)); }
# %
# size: 24
#
EVFMT = "llHHi"
EVSIZE = calcsize(EVFMT)
EVBUFSZ = EVSIZE << 10 # should always exhaust unread supply

# /usr/include/linux/input-event-codes.h
class Evtype(Enum):
    EV_SYN = 0x00 # sync packet, code: 0 = SYN_REPORT, 3 = SYN_DROPPED
    EV_KEY = 0x01 # code: 0-255 kbd, > 255 buttons, val: press = 1 release = 0
    EV_REL = 0x02 # mouse relative position (mouse and touchpad)
    EV_ABS = 0x03 # mouse absolute position (touchpad only)

# mouse and keyboard event queue inserted by input device monitor threads
evq = SimpleQueue()

# one queue for keyboard and mouse events, inserted as (Qtype, count) tuples
class Qtype(IntEnum):
    QT_KEY = 0
    QT_MOUSE = 1

# global event counter and last seen packet time.time(), indexed by Qtype
events = [0, 0]
lastseen = [0.0, 0.0]

# TODO interrupts leeway before triggering not-idle (eg accidental inputs)
IRQTHRESHOLD = 3

# TODO wake up and check interrupt counters this often (seconds)
POLLSECS = 5

# global current idle state, script maintains while it runs
idle = True

#

def err(*args, **kwargs):
    print(*args, file=stderr, **kwargs)

def bomb(*args):
    err(*args)
    exit(EXIT_FAILURE)

def dprint(*args, **kwargs):
    if not debug: return
    err('debug:', *args, **kwargs)

def dprintvar(name, vars):
    if not debug: return
    err(f"debug: {name}")
    pp(vars[name])

def exe(cmd):
    return check_output(cmd.split()).splitlines()

###

def process_args():

    global args

    def addflag(p, flagchar, longopt, help=None, /, **kwargs):
        options = list(("-%s --%s" % (flagchar, longopt)).split())
        p.add_argument(*options, action='store_true', help=help, **kwargs)

    # todo: unused
    def addarg(p, vname, vdesc, help=None, /, **kwargs):
        p.add_argument(vname, nargs='?', metavar=vdesc, help=help, **kwargs)

    p = ArgumentParser(
        prog            = invname,
        description     = __doc__.strip(),
        allow_abbrev    = False,
        formatter_class = RawTextHelpFormatter,
    )
    addflag (p, 'd', 'debug')

    args = p.parse_args(args)


def check_sanity():
    pass

###

def get_keyboard_event_paths():
    pass

def get_mouse_event_paths():
    pass

def get_event_paths():
    paths = {}
    for suffix in ['kbd', 'mouse']:
        paths[suffix] = glob(f"/dev/input/by-path/*-event-{suffix}")
    return paths

#

def update_counts(cntsobj, counts=None):
    if not counts:
        pass

# get a batch of event packets from given input device fd and update
# counters.  we should always get a multiple of EVSIZE from the read(),
# and each set of batched EVSIZE events will always terminate with an
# EV_SYN event.  in testing, each read() got exactly one set of related
# events (ie, only one EV_SYN was present in the read buffer, and it was
# always the last input_event), but we don't know for sure if multiple
# event sets can come from a single read()
#
def queue_events(fd):

    while True:

        seen = processed = 0
        kevs = mevs = 0

        try: evbuf = read(fd, EVBUFSZ)
        except Exception as e: err(f"exception: {e}"); raise

        for event in iter_unpack(EVFMT, evbuf):
            secs, usecs, itype, code, val = event
            seen += 1
            try: t = Evtype(itype)
            except ValueError:
                continue # ignore unknown types
            if debug:
                dprint(f"fd{fd}: type:{itype}, code:{code}, value:{val}")
            if t is Evtype.EV_KEY:
                if code <= 255 and val == 1: # ignore buttons and key releases
                    kevs += 1
            elif t is Evtype.EV_SYN:
                # we don't care to count batches, only events.  we don't
                # care about SYN_DROPPED either: unlikely, and safe to ignore
                continue
            else:
                mevs += 1
            processed += 1

        if t is not Evtype.EV_SYN:
            bomb(f"fd {fd}: sync packet not last!")

        if debug:
            dprint(f"fd{fd}: saw {seen}, processed {processed}, "
                   f"key {kevs}, mouse {mevs}")

        # struct timeval fields to time.time() float
        timetime = secs + usecs / 1000000.0

        if kevs: evq.put((Qtype.QT_KEY, timetime, kevs))
        if mevs: evq.put((Qtype.QT_MOUSE, timetime, mevs))


def process_events():

    while True:
        qtype, timetime, count = evq.get()
        events[qtype] += count
        lastseen[qtype] = timetime
        print(f"events: {lastseen} {events}")


# spawn threads to block on input events and queue the ones we care
# about.  then we have another thread that blocks on queue.get() and
# processes the events.  note: to_thread() uses ThreadPoolExecutor which
# makes daemon threads, and therefore exceptions are not automatically
# printed (main thread dies and program is terminated), so portions of
# these tasks that can except need to catch/print/raise themselves. see
#  https://stackoverflow.com/questions/875453
#  https://stackoverflow.com/questions/49992329
#
async def monitor_events(fds):

    tasks = []
    for fd in fds:
        tasks.append(create_task(to_thread(queue_events, fd)))

    tasks.append(create_task(to_thread(process_events)))

    await wait(tasks, return_when=FIRST_EXCEPTION)

    # even though an excepting thread won't print exception, it will
    # return here so at least we'll know an excpetion occurred
    #
    bomb("monitor thread exception")


def idled():

    paths = sum(get_event_paths().values(), [])
    dprintvar('paths', vars())

    fds = [osopen(path, O_RDONLY) for path in paths]

    try: run(monitor_events(fds))
    except KeyboardInterrupt: killpg(getpgid(0), SIGTERM)
    # ^^^ todo why requires ctrl-c twice?

    exit(EXIT_SUCCESS)

###

def main():

    if debug == 1:
        breakpoint()

    process_args()
    check_sanity()

    chdir("/")

    try: subprogram = globals()[invname]
    except (KeyError, TypeError):
        bomb(f"unimplemented command '{invname}'")

    return subprogram()

###

if __name__ == "__main__":

    from sys import hexversion
    if hexversion < 0x03090000:
        bomb("minimum python 3.9")

    from bdb import BdbQuit
    debug = int(getenv('DEBUG') or 0)
    if debug:
        from pprint import pp
        err('debug: enabled')

    invname = basename(argv[0])
    args = argv[1:]

    try: main()
    except BdbQuit: bomb("debug: stop")
